import numpy as npfrom astropy.cosmology import WMAP9import astropy.units as ufrom astropy.constants import c,L_sunfrom copy import deepcopyc = c.valueL_sun = L_sun.valuedef get_luminosity(Lambdas=None,frequencies=None,Snu=None,distance=None,z=None,restframe=False):    """    Routine to calculate the integrated luminosity of an object, given arrays    of wavelengths (or frequencies) and brightnesses.        One of Lambdas,frequencies is required, as is one of distance,z        Arguments:    Lambdas: array of floats or Quantity's, optional        Wavelengths corresponding to the flux densities passed        Assumed in um if not unit provided    frequencies: array of floats or Quantity's, optional        Frequencies corresponding to the flux densities passed        Assumed in GHz if not unit passed    Snu: array of floats or Quantity's, required        Flux densities of frequencies/wavelengths provided        Assumed in mJy if no unit passed    distance: float or Quantity, optional        Distance to object in question, assumed in Mpc if no unit provided    z: float, optional        Redshift of object used for distance calculation; WMAP9 cosmology assumed    restframe: Boolean, default False        whether wavelengths / frequencies are in the rest or observed frame        Returns:    L: float        Luminosity of the object, in Lsun    """    Lambdas = deepcopy(Lambdas)    frequencies = deepcopy(frequencies)    Snu = deepcopy(Snu)    distance = deepcopy(distance)    z = deepcopy(z)    # Do some unit handling & input checking    if (Lambdas is None) and (frequencies is None): raise ValueError("Either Lambdas or frequencies must be provided!")    if Snu is None: raise ValueError("Snu is required!")    if frequencies is not None:        frequencies *= 1e9                    # If no provided units, assume GHz were passed    if Lambdas is not None:        Lambdas *= 1e-6                       # If no provided units, assume um were passed        frequencies = c / Lambdas    if (z is None) and (distance is None): raise ValueError("Either distance or z must be provided!")    if distance:        if hasattr(distance,'unit'):            distance = distance.to('m').value        else: distance = u.Quantity(distance,'Mpc').to('m').value    if z:        distance = u.Quantity(WMAP9.luminosity_distance(z),'Mpc').to('m').value        # If rest-frame freqs/lambdas were provided, have to get them to observed frame    if restframe: frequencies /= (1. + z)            # Okay, now everything should be in SI (and Jy) and the observer's frame    # Technically this makes the first array element have bandwidth max(nu) - min(nu), so    #  instead make the zero-eth element have less bandwidth    dnu = np.abs(np.roll(frequencies,1) - frequencies)    dnu[0] = dnu[1]    Snudnu = Snu * dnu    intflux = 1e-29 * Snudnu.sum()              # Calculate integrated flux, convert to SI        return 4.*np.pi * distance**2. * intflux / L_sun        """    # Turn off astropy's warning about changing the DL scalar to an array    u.quantity.WARN_IMPLICIT_NUMERIC_CONVERSION.set(False)    # Allow user to pass a luminosity distance to avoid calculating this quantity for every    # step in a chain (why calc the same number X00,000 times?); otherwise calculate it.        if not DL:        DL = WMAP9.luminosity_distance(z)    nu=c/(um_arr*1e-6)    dnu=abs(roll(nu,1)-nu)    fdnu=mJy_arr*dnu/(1.+z)    intflux=sum(fdnu)    #                                                                             mJy->W/m^2/Hz      luminosity=4*pi*(u.Mpc.to(u.m,DL)**2)*intflux/(L_sun*1.e29)    return luminosity    """